#!/usr/bin/perl -w
#
# ws1001wxdata.pl: Ver 1.4
#
# This program establishes a TCP connection with the ws1001 console and
# obtains the real time weather data generated by the sensor array.
# It writes an output file containing the ws1001 weather data in a format
# compatible with the cumulus easyweather.dat input file.

use utf8;
use File::Basename;
use Getopt::Std;
use Time::Local;
use IO::Socket::INET;
use Net::Domain qw(hostname hostfqdn hostdomain);
use sigtrap qw(die INT QUIT);

# options
$opt_d = "";    # specify output debug file

getopts('d:');

if (@ARGV != 3)
{
    print "Usage: $0 [-d debugfile] search_msgfile req_record_msgfile ewcumulus_file\n";
    exit -1;
}

$bcmsgfile	= $ARGV[0];	# broadcast udp search message
$sndmsgfile 	= $ARGV[1];	# message to be sent to EW console (ws1001)
$ewcumulusfile 	= $ARGV[2]; 	# output data file to be read by cumulus

my $dbugfile = $opt_d;

print "*** ws1001wxdata.pl started ", scalar(localtime(time())), "\n";

##$SIG{PIPE} = sub { };

# initialize ewdat
@ewdata = ("x") x 36;

$f2c = 5./9.;

@compass = ("N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW", "N");

my $tcpport = 6500;	# tcp port	# console connection
my $udpport = 36745;	# udp port	# broadcast message port
##my $tcpport = 8888;	# tcp port
##my $udpport = 7777;	# udp port

my $wxupdate	= 12;	# approximate wx data update interval (sec)
my $tcptimeout 	= 20;	# waiting for client connection timeout

my $maxtry	= 3;	# max attemps to write EW output file
my $trycnt 	= 0;
my $maxalrm 	= 5;	# max number of connection timeouts
my $maxreset 	= 10;	# max number of consecutive connection resets
my $resetcnt	= 0;
my $ltwd 	= 0;
my $ltyd 	= 0;
my $lti 	= 0;

open(BCM, "<", $bcmsgfile)
            || die("$0: ERROR Could not open input file, $bcmsgfile. $!\n");

@bcmsgline = (<BCM>);	# Read SEARCH UDP broadcast message
close(BCM);

open(MSG, "<", $sndmsgfile)
            || die("$0: ERROR Could not open input file, $sndmsgfile. $!\n");

@sndmsgline = (<MSG>);	# Read NOWRECORD request message to be sent to console
close(MSG);

my $host = hostname;					# Local host name
my $hostaddr = inet_ntoa(scalar gethostbyname($host));	# Local host IP addr

print "local host addr = $hostaddr\n";

@ipaddr = split(/\./, $hostaddr);
$bcaddr = "${ipaddr[0]}.${ipaddr[1]}.${ipaddr[2]}.255";	# local broadcast addr

$bcaddr = "${bcaddr}:6000";	# broadcast addr
##$bcaddr = "${bcaddr}:5555";	
print "broadcast address = $bcaddr\n";

RESET:
my $sndcnt = 0;
my $alrmcnt = 0;

# auto-flush on socket
$| = 1;
 
# Create the TCP socket
my $tcpsocket = new IO::Socket::INET (
    LocalHost => $hostaddr,
    LocalPort => $tcpport,
    Proto => 'tcp',
    Listen => 5,
    Reuse => 1
);

die "Cannot create TCP socket $!\n" unless $tcpsocket;

UDPSEND:
sleep(10);

# Create the UDP Socket.
my $udpsocket = new IO::Socket::INET (
    LocalPort  => $udpport,
    PeerAddr   => $bcaddr,
    Proto        => 'udp',
    Broadcast => 1
);

die "Cannot create UDP socket $!\n" unless $udpsocket;

# Send broadcast SEARCH message
my $udpmsize = $udpsocket->send($bcmsgline[0]);
print "Sent UDP broadcast message of length $udpmsize\n";

# notify server that request has been sent
shutdown($udpsocket, 1);

$udpsocket->close();

print "Server waiting for WS1001 console connection on port $tcpport\n";

eval {
    local $SIG{ALRM} = sub { die "alarm\n" }; # NB: \n required
    alarm($tcptimeout);

    # waiting for a new client connection (WS1001 console)
    $client_socket = $tcpsocket->accept();
    alarm(0);
};

if ($@) {			  # connection timeout
    die unless $@ eq "alarm\n";   # propagate unexpected errors
    print "client connection timeout\n";
    $alrmcnt++;
    alarm(0);

    if($alrmcnt > $maxalrm) {
	die("$0: Timed out waiting for client (console) connection $!\n");
    }
	
    goto UDPSEND;	# Send another UDP broadcast message
}
 
# get information about a newly connected client
my $client_address = $client_socket->peerhost();
my $client_port = $client_socket->peerport();
print "connection from $client_address:$client_port\n";

while(1) {	# TCP socket send/receive loop
 
    # send message to the connected client (console)
    my $rcvmsg = "";

    if(defined $client_socket->peerhost()) {
    	my $tcpmsize = $client_socket->send($sndmsgline[0]);
    	if(! $sndcnt) {
    	    print "Sent data request message to console ($tcpmsize bytes)\n";
    	}

    	# read up to 1024 characters from the connected client
    	$client_socket->recv($rcvmsg, 1024);

    	$client_msg_size = length($rcvmsg);

    	# Unpack NOWRECORD message received from console
    	(@msgcontent) = unpack("A8 A8 Z16 S C I C S C2 f14 C2", $rcvmsg);

    	$msglen = scalar(@msgcontent);
    	if(! $sndcnt) {
    	    print "Received data message from console ($client_msg_size bytes)\n";
    	    print "Received message size = $msglen \n";
	    print "... \n";
	    $sndcnt++;
    	}
    }
    else {	# console is disconnected
	print "Cannot determine peer address. \n";
	$client_msg_size = 0;
	$msglen = 0;
    }

    # Check received message properties
    if(($msgcontent[2] ne "NOWRECORD") || ($msglen < 24)) {
	if($client_msg_size) {
    	    print "Received data message ($client_msg_size bytes)\n";
	    print "Unexpected console message of size = $msglen \n";
	    
	    if($msglen > 2) {
	    	print "HP_HEAD = $msgcontent[0] \n";
	    	print "HP_CMD = $msgcontent[1] \n";
	    	print "HP_TABLE = $msgcontent[2] \n";
	    }
	    if($dbugfile) {
	    	if(open(RMG, ">", $dbugfile)) {
	    	    printf(RMG "received message: \n");
	    	    printf(RMG "%s", $rcvmsg);
	    	    close(RMG);
	    	}
	        else {
		    print "Could not open output debug file, $dbugfile. $!\n";
		    $dbugfile = "";
	        }
	    }
	}
	elsif($msglen > 0) {
	    print "Unknown response \n";
	}

	shutdown($tcpsocket, 2);
	$tcpsocket->close();

	if($resetcnt >= $maxreset) {
	    print "Program stopped: max resets = $resetcnt \n";
	    exit(2);
	}
	$resetcnt++;
	sleep(10);
 	print "*** connection reset: ", scalar(localtime(time())), "\n";
	goto RESET;	# reset TCP connection
    }
    $resetcnt = 0;

    # get current time
    ($sec, $min, $hour, $day, $month, $year, $ltwd, $ltyd, $lti) = localtime;
    $year += 1900;
    $month++;
    
    $strhour = sprintf ("%02d", $hour);
    $strmin = sprintf ("%02d", $min);
    $strsec = sprintf ("%02d", $sec);

    # convert date to yyyy-mm-dd format
    $ewdata[3] = "${year}-${month}-${day}";     	# date
    $ewdata[4] = "${strhour}:${strmin}:${strsec}";	# time
 
    # indoor humidity
    if($msgcontent[8] =~ /\d/) {
        $ewdata[6] = sprintf("%.0f", $msgcontent[8]);
    }
    else { $ewdata[6] = $msgcontent[8]; }

    # convert units from us to metric
    # indoor temp
    if($msgcontent[10] =~ /\d/) {
        $ewdata[7] = ($msgcontent[10] - 32.) * $f2c;
    }
    else { $ewdata[7] = $msgcontent[10]; }

    # outdoor humidity
    if($msgcontent[9] =~ /\d/) {
        $ewdata[8] = sprintf("%.0f", $msgcontent[9]);
    }
    else { $ewdata[8] = $msgcontent[9]; }

    # outdoor temp
    $ewdata[9] = (($msgcontent[13] =~ /\d/) ? (($msgcontent[13] - 32.) * $f2c) : $msgcontent[13]);

    #dewpoint
    $ewdata[10] = (($msgcontent[14] =~ /\d/) ? (($msgcontent[14] - 32.) * $f2c) : $msgcontent[14]);

    # windchill
    $ewdata[11] = (($msgcontent[15] =~ /\d/) ? (($msgcontent[15] - 32.) * $f2c) : $msgcontent[15]);

    # barometer
    $ewdata[13] = (($msgcontent[12] =~ /\d/) ? ($msgcontent[12] * 33.8639) : $msgcontent[12]);

    # wind average
    $ewdata[14] = (($msgcontent[16] =~ /\d/) ? ($msgcontent[16] * .44704) : $msgcontent[16]);

    # wind gust
    $ewdata[16] = (($msgcontent[17] =~ /\d/) ? ($msgcontent[17] * .44704) : $msgcontent[17]);

    # wind direction
    # Use compass for wind direction (NNW)
    $cdir = $msgcontent[7]/22.5;
    $compdir = sprintf ("%.0f", $cdir);
    $ewdata[19] = $compass[int($compdir)];

    # rain in last hour
    # Cumulus uses this value for rain rate (in/hour)
    # Use ws1001 rain rate value (in/hour)
    $ewdata[23] = (($msgcontent[18] =~ /\d/) ? ($msgcontent[18] * 25.4) : $msgcontent[18]);

    # rain in last year
    $ewdata[27] = (($msgcontent[22] =~ /\d/) ? ($msgcontent[22] * 25.4) : $msgcontent[22]);

    # solar radiation (Lux)
    # convert W/m2 to lux: 1 W/m2 = 126.7 lux
    $ewdata[28] = (($msgcontent[23] =~ /\d/) ? ($msgcontent[23] * 126.7) : $msgcontent[23]);
    $ewdata[29] = $msgcontent[24];                  # UV Index

    if(open(EWP, ">", $ewcumulusfile)) {
        $trycnt = 0;
    }
    elsif($trycnt < $maxtry) {
        $trycnt++;
        print "$0 : ", scalar(localtime(time())), "\n";
        print "$0 - could not open output file, will try again ($trycnt)\n";
        sleep(60);
        next;
    }
    else {
        die("$0: ERROR Could not open output file, $ewcumulusfile. $!\n");
    }

    for($i = 0; $i < @ewdata; $i++) {
        printf(EWP "%s ", $ewdata[$i]);
    }
    printf(EWP "\n");
    close(EWP);

    sleep($wxupdate);
}
 
$tcpsocket->close();

exit(0);
