#!/usr/bin/perl -w
#
# ws1001wxdata.pl: Ver 1.19 (Raspberry Pi Linux)
#
# This program establishes a TCP connection with the ws1001 console and
# obtains the real time weather data generated by the sensor array.
# It writes an output file containing the ws1001 weather data in a format
# compatible with the cumulus easyweather.dat input file.
# Weather data values received from the console are expected to be given
# in US units (not metric).
# Use -m option if console displays wx data in metric units.
# Use -a option to check for wx alarms
# Use -p option to get Pi host address

use utf8;
use File::Basename;
use Getopt::Std;
use Time::Local;
use IO::Socket::INET;
use Net::Domain qw(hostname hostfqdn hostdomain);
use sigtrap qw(die INT QUIT);

$dbtest = 0;

# options
$opt_d = "";    # specify output debug file
$opt_a = "";    # send email alerts
$opt_m = "";    # console wx data is given in metric units
$opt_i = "";    # specify local host IP addr
$opt_p = "";    # use to get Pi host address

getopts('a:md:i:p');

if (@ARGV != 3)
{
    print "Usage: $0 [-a alert_file] [-m] [-i ipaddr] [-p] [-d debugfile] search_msgfile req_record_msgfile ewcumulus_file\n";
    print "Options: \n";
    print "         -a email alert file\n";
    print "         -m ws1001 console uses metric units (otherwise console uses US units)\n";
    print "         -i specify local host ip addr (otherwise program determines ip addr)\n";
    print "         -p use to get Raspberry Pi local host ip addr automatically\n";
    print "         -d specify dbug file for certain connection errors\n";
    exit -1;
}

$bcmsgfile	= $ARGV[0];	# broadcast udp search message
$sndmsgfile 	= $ARGV[1];	# message to be sent to EW console (ws1001)
$ewcumulusfile 	= $ARGV[2]; 	# output data file to be read by cumulus

my $alertfile 	= $opt_a;
my $dbugfile 	= $opt_d;
my $hostaddr 	= $opt_i;

print "*** ws1001wxdata.pl started ", scalar(localtime(time())), "\n";

##$SIG{PIPE} = sub { };

# initialize ewdat
@ewdata = ("x") x 36;
@msgcontent = ("0") x 3;

if($opt_m) { 	# console displays data in metric units
    $frztemp = 0.;
    $tfactor = 1.;
    $pfactor = 1.;
    $wfactor = 1.;
    $rfactor = 1.;
}
else {		# console displays data in US units
    $frztemp = 32.;
    $tfactor = 5./9.;
    $pfactor = 33.8639;
    $wfactor = .44704;
    $rfactor = 25.4;
}

if($alertfile) {
    $wxalarmchk 	= 1;
    $alarmname 		= "Outside Temperature";
    $wxdaval_hi 	= 90.;
    $wxdaval_lo		= 32.;
    $alarmtime 		= 0;
    $alrmchkint 	= 86400;	# alarm interval in seconds - one day
}
else {
    $wxalarmchk = 0;
}

@compass = ("N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW", "N");

my $tcpport = 6500;	# tcp port	# console connection
my $udpport = 36745;	# udp port	# broadcast message port
if($dbtest) {
    $tcpport = 8888;	# tcp port
    $udpport = 7777;	# udp port
}

my $wxupdate	= 12;	# approximate wx data update interval (sec)
my $tcptimeout 	= 20;	# waiting for client connection timeout

my $maxtry	= 3;	# max attemps to write EW output file
my $trycnt 	= 0;
my $maxalrm 	= 25;	# max number of wait for connection timeouts
my $maxreset 	= 10;	# max number of consecutive connection resets
my $resetcnt	= 0;
my $maxunkmsg	= 5;	# Reset after this number of unknown messages
my $ltwd 	= 0;
my $ltyd 	= 0;
my $lti 	= 0;
my $aptrymax	= 5;

open(BCM, "<", $bcmsgfile)
            || die("$0: ERROR Could not open input file, $bcmsgfile. $!\n");

@bcmsgline = (<BCM>);	# Read SEARCH UDP broadcast message
close(BCM);

open(MSG, "<", $sndmsgfile)
            || die("$0: ERROR Could not open input file, $sndmsgfile. $!\n");

@sndmsgline = (<MSG>);	# Read NOWRECORD request message to be sent to console
close(MSG);

my $host = hostname;					# Local host name
if(! $hostaddr) {

    if($opt_p) {
    	# get local host IP addr using Linux ifconfig
	my $ifconfig = "";
    	$ifconfig = `ifconfig | grep Bcast`;
	if(!$ifconfig) {
	    print "Local host ip addr not found. Use -i option to specify local host ip addr.\n";
            exit(2);
	}
    	($hostaddr, $ifconfig) = split(/Bcast/, $ifconfig);
    	$hostaddr =~ s/inet addr://;
    	$hostaddr =~ s/\s//g;
    }
    else {
	$hostaddr = inet_ntoa(scalar gethostbyname($host));  # Local host IP addr
    }
}

print "local host addr = $hostaddr\n";

@ipaddr = split(/\./, $hostaddr);
$bcaddr = "${ipaddr[0]}.${ipaddr[1]}.${ipaddr[2]}.255";	# local broadcast addr

if($dbtest) {
    $bcaddr = "${bcaddr}:5555";	
}
else {
    $bcaddr = "${bcaddr}:6000";     # broadcast addr
}
print "broadcast address = $bcaddr\n";

RESET:
my $sndcnt 	= 0;
my $alrmcnt 	= 0;
my $unkmsgcnt 	= 0;
my $aptrycnt    = 0;

# auto-flush on socket
$| = 1;
 
# Create the TCP socket
my $tcpsocket = new IO::Socket::INET (
    LocalHost => $hostaddr,
    LocalPort => $tcpport,
    Proto => 'tcp',
    Listen => 5,
    Timeout  => $tcptimeout,
    Reuse => 1
);

##die "Cannot create TCP socket $!\n" unless $tcpsocket;
if(!$tcpsocket) {
    print "Cannot create TCP socket $!\n";
    if($resetcnt >= $maxreset) {
        print "Program stopped: max resets = $resetcnt \n";
        exit(2);
    }

    $resetcnt++;
    sleep(600);		# wait 10 minutes
    print "*** connection reset: ", scalar(localtime(time())), "\n";
    goto RESET;     # reset TCP connection
}

UDPSEND:
sleep(10);

# Create the UDP Socket.
my $udpsocket = new IO::Socket::INET (
    LocalPort  => $udpport,
    PeerAddr   => $bcaddr,
    Proto        => 'udp',
    Broadcast => 1
);

die "Cannot create UDP socket $!\n" unless $udpsocket;

# Send broadcast SEARCH message
my $udpmsize = $udpsocket->send($bcmsgline[0]);
print "Sent UDP broadcast message of length $udpmsize\n";

# notify server that request has been sent
shutdown($udpsocket, 1);

$udpsocket->close();

print "Server waiting for WS1001 console connection on port $tcpport\n";

# waiting for a new client connection (WS1001 console)
$client_socket = $tcpsocket->accept();

if(! defined $client_socket) {
    $alrmcnt++;
    if($alrmcnt >= $maxalrm) {
	print "$0: Timed out waiting for client (console) connection: $!\n";
        if($resetcnt >= $maxreset) {
            print "Program stopped: max resets = $resetcnt \n";
            exit(2);
        }
	shutdown($tcpsocket, 2);
        $tcpsocket->close();

        $resetcnt++;
        sleep(10);
        print "*** connection reset: ", scalar(localtime(time())), "\n";
        goto RESET;     # reset TCP connection
    }
    goto UDPSEND;       # Send another UDP broadcast message
}
 
# get information about a newly connected client
my $client_address = $client_socket->peerhost();
my $client_port = $client_socket->peerport();
print "connection from $client_address:$client_port\n";

while(1) {	# TCP socket send/receive loop
 
    # send message to the connected client (console)
    my $rcvmsg = "";

    if(defined $client_socket->peerhost()) {
    	my $tcpmsize = $client_socket->send($sndmsgline[0]);
	if(defined $tcpmsize) {
    	    if(! $sndcnt) {
    	        print "Sent data request message to console ($tcpmsize bytes)\n";
    	    }

    	    # read up to 1024 characters from the connected client
    	    $client_socket->recv($rcvmsg, 1024);

    	    $client_msg_size = length($rcvmsg);

    	    # Unpack NOWRECORD message received from console
    	    (@msgcontent) = unpack("A8 A8 Z16 S C I C S C2 f14 C2", $rcvmsg);

    	    $msglen = scalar(@msgcontent);
    	    if(! $sndcnt) {
    	        print "Received data message from console ($client_msg_size bytes)\n";
    	        print "Received message size = $msglen \n";
	        print "... \n";
	        $sndcnt++;
    	    }
	}
	else { 	# message send failed
	    print "Data request message send failed. \n";
	    $client_msg_size = 0;
	    $msglen = 0;
	}
    }
    else {	# console is disconnected
	print "Cannot determine peer address. \n";
	$client_msg_size = 0;
	$msglen = 0;
    }

    # Check received message properties
    if(($msglen < 24) || ($msgcontent[2] ne "NOWRECORD")) {
	if($client_msg_size) {
    	    print "Received data message ($client_msg_size bytes)\n";
	    print "Unexpected console message of size = $msglen \n";
	    
	    if($msglen > 2) {
	    	print "HP_HEAD = $msgcontent[0] \n";
	    	print "HP_CMD = $msgcontent[1] \n";
	    	print "HP_TABLE = $msgcontent[2] \n";
	    }
	    if($dbugfile) {
	    	if(open(RMG, ">", $dbugfile)) {
	    	    printf(RMG "received message: \n");
	    	    printf(RMG "%s", $rcvmsg);
	    	    close(RMG);
	    	}
	        else {
		    print "Could not open output debug file, $dbugfile. $!\n";
		    $dbugfile = "";
	        }
	    }
	}
	elsif($msglen > 0) {
	    print "Unknown response: message length = $msglen \n";
	    $unkmsgcnt++;
	    if($unkmsgcnt <= $maxunkmsg) {
		    goto SKIP;
            }
	}

	shutdown($tcpsocket, 2);
	$tcpsocket->close();

	if($resetcnt >= $maxreset) {
	    print "Program stopped: max resets = $resetcnt \n";
	    exit(2);
	}
	$resetcnt++;
	sleep(10);
 	print "*** connection reset: ", scalar(localtime(time())), "\n";
	goto RESET;	# reset TCP connection
    }
    $resetcnt = 0;

    # get current time
    ($sec, $min, $hour, $day, $month, $year, $ltwd, $ltyd, $lti) = localtime;
    $year += 1900;
    $month++;

    # Make sure rain total is reset at the beginning of the new year
    if(($month == 1) && ($day == 1) && ($hour == 0) && ( $min <= 2)) {
	$msgcontent[22] = 0.;		# console rain total
    }
    
    $strhour = sprintf ("%02d", $hour);
    $strmin = sprintf ("%02d", $min);
    $strsec = sprintf ("%02d", $sec);

    # convert date to yyyy-mm-dd format
    $ewdata[3] = "${year}-${month}-${day}";     	# date
    $ewdata[4] = "${strhour}:${strmin}:${strsec}";	# time
 
    # indoor humidity
    if($msgcontent[8] =~ /\d/) {
        $ewdata[6] = sprintf("%.0f", $msgcontent[8]);
    }
    else { $ewdata[6] = $msgcontent[8]; }

    # if required convert units from us to metric
    # indoor temp
    if($msgcontent[10] =~ /\d/) {
        $ewdata[7] = ($msgcontent[10] - $frztemp) * $tfactor;
    }
    else { $ewdata[7] = $msgcontent[10]; }

    # outdoor humidity
    if($msgcontent[9] =~ /\d/) {
        $ewdata[8] = sprintf("%.0f", $msgcontent[9]);
    }
    else { $ewdata[8] = $msgcontent[9]; }

    # outdoor temp
    $ewdata[9] = (($msgcontent[13] =~ /\d/) ? (($msgcontent[13] - $frztemp) * $tfactor) : $msgcontent[13]);
    if($ewdata[9] > 100.) { goto SKIP; }        # corrupted wx data

    #dewpoint
    $ewdata[10] = (($msgcontent[14] =~ /\d/) ? (($msgcontent[14] - $frztemp) * $tfactor) : $msgcontent[14]);

    # windchill
    $ewdata[11] = (($msgcontent[15] =~ /\d/) ? (($msgcontent[15] - $frztemp) * $tfactor) : $msgcontent[15]);

    # barometer
    $ewdata[13] = (($msgcontent[12] =~ /\d/) ? ($msgcontent[12] * $pfactor) : $msgcontent[12]);
    if(($ewdata[13] > 1356.) || ($ewdata[13] < 678.)) { goto SKIP; } # corrupted wx data

    # wind average
    $ewdata[14] = (($msgcontent[16] =~ /\d/) ? ($msgcontent[16] * $wfactor) : $msgcontent[16]);
    if($ewdata[14] > 200.) { goto SKIP; }       # corrupted wx data

    # wind gust
    $ewdata[16] = (($msgcontent[17] =~ /\d/) ? ($msgcontent[17] * $wfactor) : $msgcontent[17]);
    if($ewdata[16] > 200.) { goto SKIP; }       # corrupted wx data

    # wind direction
    # Use compass for wind direction (NNW)
    $cdir = $msgcontent[7]/22.5;
    $compdir = sprintf ("%.0f", $cdir);
    if(int($compdir) >= @compass) { goto SKIP; }       # corrupted wx data
    $ewdata[19] = $compass[int($compdir)];

    # rain in last hour
    # Cumulus uses this value for rain rate (in/hour or mm/hour)
    # Use ws1001 rain rate value (in/hour or mm/hour)
    $ewdata[23] = (($msgcontent[18] =~ /\d/) ? ($msgcontent[18] * $rfactor) : $msgcontent[18]);

    # rain in last year
    $ewdata[27] = (($msgcontent[22] =~ /\d/) ? ($msgcontent[22] * $rfactor) : $msgcontent[22]);

    # solar radiation (Lux)
    # convert W/m2 to lux: 1 W/m2 = 126.7 lux
    $ewdata[28] = (($msgcontent[23] =~ /\d/) ? ($msgcontent[23] * 126.7) : $msgcontent[23]);
    $ewdata[29] = $msgcontent[24];                  # UV Index

    if(open(EWP, ">", $ewcumulusfile)) {
        $trycnt = 0;
    }
    elsif($trycnt < $maxtry) {
        $trycnt++;
        print "$0 : ", scalar(localtime(time())), "\n";
        print "$0 - could not open output file, will try again ($trycnt)\n";
        sleep(60);
        next;
    }
    else {
        die("$0: ERROR Could not open output file, $ewcumulusfile. $!\n");
    }

    for($i = 0; $i < @ewdata; $i++) {
        printf(EWP "%s ", $ewdata[$i]);
    }
    printf(EWP "\n");
    close(EWP);

    # Send WX alert if necessary
    if($wxalarmchk) {
	$wxdvalue = sprintf ("%.1f", "$msgcontent[13]"); # outside temp
	if(($wxdvalue <= $wxdaval_lo) || ($wxdvalue >= $wxdaval_hi)) {
		$wxalertdata = $wxdvalue;
                $alarmchktime = time();
                if($alarmchktime > $alarmtime) {
		    $now = scalar localtime(time());
		    $wxmsg = sprintf ("%s", "$now\nWeather Station Alarm: $alarmname = $wxalertdata\n");
                    if(open(AF, ">", $alertfile)) {
			printf(AF "%s", $wxmsg);
                        close(AF);
			print "$wxmsg";
			$alarmtime = $alarmchktime + $alrmchkint;
			$aptrycnt = 0;
                    }
		    elsif($aptrycnt >= $aptrymax) { 	# stop trying this time
			$alarmtime = $alarmchktime + $alrmchkint;
			$aptrycnt = 0;
		    }
                    else {
			$aptrycnt++;
                        print "Could not open output wx alert file, $alertfile. $!\n";
                    }
                }
        }
    }

SKIP:
    sleep($wxupdate);
}
 
$tcpsocket->close();

exit(0);
